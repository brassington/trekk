<?php
<?php
/**
 * @file
 * Administrative forms and pages
 */

/**
 * Dashboard form builder. Provides a basic alternative to the migrate ui dashboard
 */
function trekk_client_aggregator_dashboard($form, &$form_state, $machine_name) {
  module_load_include('inc', 'migrate_ui', 'migrate_ui.pages');  
  
  $form = array();
  
  $form['operation'] = array(
    '#type' => 'select',
    '#title' => t('Operations'),
    '#description' => t('Warning: rolling back removes all mapped entities. There is no way to roll back an update.'),
    '#options' => array(
      'update' => t('Update'),
      'import' => t('Import'),
      'rollback' => t('Roll back'),
      'stop' => t('Stop'),
      'reset' => t('Reset'),
      ),
    '#empty_option' => '--' . t('Select one') . '--',
    '#empty_value' => '',
    );

  $form['limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Limit'),
    );

  $form['dashboard'] = array(
    '#type' => 'value',
    '#value' => array($machine_name),
    '#multiple_values' => TRUE,
    );

	$form['actions']['submit'] = array(
	  '#type' => 'submit',
	  '#value' => t('Submit'),
	  );

	return $form;
}

/**
 * Validation handler for trekk_client_aggregator_dashboard form
 */
function trekk_client_aggregator_dashboard_validate($form, &$form_state) {}

/**
 * Submit handler for trekk_client_aggregator_dashboard form
 */
function trekk_client_aggregator_dashboard_submit($form, &$form_state) {
  $operation = $form_state['values']['operation'];
  $limit = $form_state['values']['limit'] ? $form_state['values']['limit'] : 0;
  $machine_name = (string)array_shift($form_state['values']['dashboard']);

  $operations = array();
  $operations[] = array('trekk_client_batch', array($operation, $machine_name, $limit));

  $batch = array(
    'operations' => $operations,
    'title' => t('Aggregator @op processing', array('@op' => $operation)),
    'file' => drupal_get_path('module', 'trekk_client') . '/trekk_client.admin.inc',
    'init_message' => t('Starting aggregation process'),
    'progress_message' => t(''),
    'error_message' => t('An error occurred. Some or all of the aggregation processing has failed.'),
    'finished' => 'trekk_client_batch_finish',
  );

  batch_set($batch);
}

/**
 * Batch operation callback for performing an aggregation
 */
function trekk_client_batch($operation, $machine_name, $limit, &$context) {
  // If we got a stop message, skip everything else
  if (isset($context['results']['stopped'])) {
    $context['finished'] = 1;
    return;
  }

  $migration = Migration::getInstance($machine_name);

  // Messages generated by migration processes will be captured in this global
  global $_migrate_messages;
  $_migrate_messages = array();
  $migration->setOutputFunction('trekk_client_capture_message');

  // Perform the requested operation
  switch ($operation) {
  	case 'update':
  	  watchdog('client', t('doing update'));
  	  $migration->prepareUpdate();
  	  $result = $migration->processImport();
  	  break;
    case 'import':
      $result = $migration->processImport(array('limit' => $limit));
      break;
    case 'rollback':
      $result = $migration->processRollback(array('limit' => $limit));
      break;
    case 'stop':
      $migration->stopProcess();
      $result = Migration::RESULT_COMPLETED;
      break;
    case 'reset':
      $migration->resetStatus();
      $result = Migration::RESULT_COMPLETED;
      break;
  }

  switch ($result) {
    case Migration::RESULT_INCOMPLETE:
      // Default to half-done, in case we can't get a more precise fix
      $context['finished'] = .5;
      if (method_exists($migration, 'sourceCount')) {
        $total = $migration->sourceCount();
        if ($total && method_exists($migration, 'importedCount')) {
          $imported = $migration->importedCount();
          switch ($operation) {
            case 'import':
              $context['finished'] = $imported/$total;
              break;
            case 'rollback':
              $context['finished'] = ($total-$imported)/$total;
              break;
          }
        }
      }
      break;
    case MigrationBase::RESULT_SKIPPED:
      $_migrate_messages[] = t('Skipped !name due to unfulfilled dependencies',
        array('!name' => $machine_name));
      $context['finished'] = 1;
      break;
    case MigrationBase::RESULT_STOPPED:
      $context['finished'] = 1;
      // Skip any further operations
      $context['results']['stopped'] = TRUE;
      break;
    default:
      $context['finished'] = 1;
      break;
  }

  // Add any messages generated in this batch to the cumulative list
  foreach ($_migrate_messages as $message) {
    $context['results'][] = $message;
  }

  // While in progress, show the cumulative list of messages
  $full_message = '';
  foreach ($context['results'] as $message) {
    $full_message .= $message . '<br />';
  }
  $context['message'] = $full_message;
}

/**
 * Batch API finished callback - report results
 *
 * @param $success
 *  Ignored
 * @param $results
 *  List of results from batch processing
 * @param $operations
 *  Ignored
 */
function trekk_client_batch_finish($success, $results, $operations) {
  unset($results['stopped']);
  foreach ($results as $result) {
    drupal_set_message($result);
  }
}

function trekk_client_capture_message($message, $level) {
  if ($level != 'debug') {
    global $_migrate_messages;
    $_migrate_messages[] = $message;
  }
}
